import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, E as validate_each_argument, v as validate_slots, e as element, A as text, p as space, a as claim_element, b as children, B as claim_text, f as detach_dev, q as claim_space, g as attr_dev, h as add_location, j as insert_dev, w as append_dev, C as set_data_dev, F as destroy_each, z as noop, G as toggle_class, H as onMount, I as goto, J as binding_callbacks, K as bind, l as create_component, m as claim_component, n as mount_component, L as add_flush_callback, t as transition_in, k as transition_out, o as destroy_component, D as query_selector_all, x as add_render_callback, M as add_resize_listener, N as check_outros, O as group_outros } from './client.281f0700.js';
import { s as svelteUrl, r as rollupUrl, m as mapbox_setup, R as Repl, S as ScreenToggle } from './config.d9ed0b54.js';

const getFragment = () => window.location.hash.slice(1);

function process_example(files) {
	return files
		.map(file => {
			const [name, type] = file.name.split('.');
			return { name, type, source: file.source };
		})
		.sort((a, b) => {
			if (a.name === 'App' && a.type === 'svelte') return -1;
			if (b.name === 'App' && b.type === 'svelte') return 1;

			if (a.type === b.type) return a.name < b.name ? -1 : 1;

			if (a.type === 'svelte') return -1;
			if (b.type === 'svelte') return 1;
		});
}

/* src/routes/examples/_TableOfContents.svelte generated by Svelte v3.31.0 */

const file = "src/routes/examples/_TableOfContents.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (109:5) {#if example.slug === active_section}
function create_if_block(ctx) {
	let a;
	let t;
	let a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			t = text("REPL");
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t = claim_text(a_nodes, "REPL");
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", a_href_value = "repl/" + /*example*/ ctx[6].slug);
			attr_dev(a, "class", "repl-link svelte-agypo9");
			add_location(a, file, 109, 6, 2160);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*sections*/ 1 && a_href_value !== (a_href_value = "repl/" + /*example*/ ctx[6].slug)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(109:5) {#if example.slug === active_section}",
		ctx
	});

	return block;
}

// (92:3) {#each section.examples as example}
function create_each_block_1(ctx) {
	let div;
	let a;
	let img;
	let img_alt_value;
	let img_src_value;
	let t0;
	let span;
	let t1_value = /*example*/ ctx[6].title + "";
	let t1;
	let a_href_value;
	let t2;
	let if_block = /*example*/ ctx[6].slug === /*active_section*/ ctx[1] && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			img = element("img");
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			img = claim_element(a_nodes, "IMG", { class: true, alt: true, src: true });
			t0 = claim_space(a_nodes);
			span = claim_element(a_nodes, "SPAN", {});
			var span_nodes = children(span);
			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "thumbnail svelte-agypo9");
			attr_dev(img, "alt", img_alt_value = "" + (/*example*/ ctx[6].title + " thumbnail"));
			if (img.src !== (img_src_value = "examples/thumbnails/" + /*example*/ ctx[6].slug + ".jpg")) attr_dev(img, "src", img_src_value);
			add_location(img, file, 101, 6, 1941);
			add_location(span, file, 106, 6, 2072);
			attr_dev(a, "href", a_href_value = "examples#" + /*example*/ ctx[6].slug);
			attr_dev(a, "class", "row svelte-agypo9");
			toggle_class(a, "active", /*example*/ ctx[6].slug === /*active_section*/ ctx[1]);
			toggle_class(a, "loading", /*isLoading*/ ctx[2]);
			add_location(a, file, 96, 5, 1791);
			attr_dev(div, "class", "row svelte-agypo9");
			toggle_class(div, "active", /*example*/ ctx[6].slug === /*active_section*/ ctx[1]);
			toggle_class(div, "loading", /*isLoading*/ ctx[2]);
			add_location(div, file, 92, 4, 1680);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, img);
			append_dev(a, t0);
			append_dev(a, span);
			append_dev(span, t1);
			append_dev(div, t2);
			if (if_block) if_block.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*sections*/ 1 && img_alt_value !== (img_alt_value = "" + (/*example*/ ctx[6].title + " thumbnail"))) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*sections*/ 1 && img.src !== (img_src_value = "examples/thumbnails/" + /*example*/ ctx[6].slug + ".jpg")) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*sections*/ 1 && t1_value !== (t1_value = /*example*/ ctx[6].title + "")) set_data_dev(t1, t1_value);

			if (dirty & /*sections*/ 1 && a_href_value !== (a_href_value = "examples#" + /*example*/ ctx[6].slug)) {
				attr_dev(a, "href", a_href_value);
			}

			if (dirty & /*sections, active_section*/ 3) {
				toggle_class(a, "active", /*example*/ ctx[6].slug === /*active_section*/ ctx[1]);
			}

			if (dirty & /*isLoading*/ 4) {
				toggle_class(a, "loading", /*isLoading*/ ctx[2]);
			}

			if (/*example*/ ctx[6].slug === /*active_section*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*sections, active_section*/ 3) {
				toggle_class(div, "active", /*example*/ ctx[6].slug === /*active_section*/ ctx[1]);
			}

			if (dirty & /*isLoading*/ 4) {
				toggle_class(div, "loading", /*isLoading*/ ctx[2]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(92:3) {#each section.examples as example}",
		ctx
	});

	return block;
}

// (88:1) {#each sections as section}
function create_each_block(ctx) {
	let li;
	let span;
	let t0_value = /*section*/ ctx[3].title + "";
	let t0;
	let t1;
	let t2;
	let each_value_1 = /*section*/ ctx[3].examples;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			li = element("li");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(li_nodes);
			}

			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "section-title svelte-agypo9");
			add_location(span, file, 89, 3, 1585);
			attr_dev(li, "class", "svelte-agypo9");
			add_location(li, file, 88, 2, 1577);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, span);
			append_dev(span, t0);
			append_dev(li, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(li, null);
			}

			append_dev(li, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*sections*/ 1 && t0_value !== (t0_value = /*section*/ ctx[3].title + "")) set_data_dev(t0, t0_value);

			if (dirty & /*sections, active_section, isLoading*/ 7) {
				each_value_1 = /*section*/ ctx[3].examples;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(li, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(88:1) {#each sections as section}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let ul;
	let each_value = /*sections*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "examples-toc svelte-agypo9");
			add_location(ul, file, 86, 0, 1520);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*sections, active_section, isLoading*/ 7) {
				each_value = /*sections*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TableOfContents", slots, []);
	let { sections = [] } = $$props;
	let { active_section = null } = $$props;
	let { isLoading = false } = $$props;
	const writable_props = ["sections", "active_section", "isLoading"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableOfContents> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("sections" in $$props) $$invalidate(0, sections = $$props.sections);
		if ("active_section" in $$props) $$invalidate(1, active_section = $$props.active_section);
		if ("isLoading" in $$props) $$invalidate(2, isLoading = $$props.isLoading);
	};

	$$self.$capture_state = () => ({ sections, active_section, isLoading });

	$$self.$inject_state = $$props => {
		if ("sections" in $$props) $$invalidate(0, sections = $$props.sections);
		if ("active_section" in $$props) $$invalidate(1, active_section = $$props.active_section);
		if ("isLoading" in $$props) $$invalidate(2, isLoading = $$props.isLoading);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [sections, active_section, isLoading];
}

class TableOfContents extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			sections: 0,
			active_section: 1,
			isLoading: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TableOfContents",
			options,
			id: create_fragment.name
		});
	}

	get sections() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active_section() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active_section(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isLoading() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isLoading(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/examples/index.svelte generated by Svelte v3.31.0 */
const file$1 = "src/routes/examples/index.svelte";

// (120:1) {#if mobile}
function create_if_block$1(ctx) {
	let screentoggle;
	let updating_offset;
	let current;

	function screentoggle_offset_binding(value) {
		/*screentoggle_offset_binding*/ ctx[12].call(null, value);
	}

	let screentoggle_props = { labels: ["index", "input", "output"] };

	if (/*offset*/ ctx[5] !== void 0) {
		screentoggle_props.offset = /*offset*/ ctx[5];
	}

	screentoggle = new ScreenToggle({
			props: screentoggle_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(screentoggle, "offset", screentoggle_offset_binding));

	const block = {
		c: function create() {
			create_component(screentoggle.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(screentoggle.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(screentoggle, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const screentoggle_changes = {};

			if (!updating_offset && dirty & /*offset*/ 32) {
				updating_offset = true;
				screentoggle_changes.offset = /*offset*/ ctx[5];
				add_flush_callback(() => updating_offset = false);
			}

			screentoggle.$set(screentoggle_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(screentoggle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(screentoggle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(screentoggle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(120:1) {#if mobile}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let title_value;
	let meta0;
	let meta1;
	let meta2;
	let t0;
	let h1;
	let t1;
	let t2;
	let div2;
	let div1;
	let tableofcontents;
	let t3;
	let div0;
	let repl_1;
	let div1_class_value;
	let t4;
	let div2_resize_listener;
	let current;
	document.title = title_value = "" + (/*title*/ ctx[7] + " " + (/*title*/ ctx[7] ? "•" : "") + " Svelte Examples");

	tableofcontents = new TableOfContents({
			props: {
				sections: /*sections*/ ctx[0],
				active_section: /*active_slug*/ ctx[1],
				isLoading: /*isLoading*/ ctx[6]
			},
			$$inline: true
		});

	let repl_1_props = {
		workersUrl: "workers",
		svelteUrl,
		rollupUrl,
		orientation: /*replOrientation*/ ctx[8],
		fixed: /*mobile*/ ctx[4],
		relaxed: true,
		injectedJS: mapbox_setup
	};

	repl_1 = new Repl({ props: repl_1_props, $$inline: true });
	/*repl_1_binding*/ ctx[11](repl_1);
	let if_block = /*mobile*/ ctx[4] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t0 = space();
			h1 = element("h1");
			t1 = text("Examples");
			t2 = space();
			div2 = element("div");
			div1 = element("div");
			create_component(tableofcontents.$$.fragment);
			t3 = space();
			div0 = element("div");
			create_component(repl_1.$$.fragment);
			t4 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1hcwu6s\"]", document.head);
			meta0 = claim_element(head_nodes, "META", { name: true, content: true });
			meta1 = claim_element(head_nodes, "META", { name: true, content: true });
			meta2 = claim_element(head_nodes, "META", { name: true, content: true });
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, "Examples");
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(tableofcontents.$$.fragment, div1_nodes);
			t3 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(repl_1.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t4 = claim_space(div2_nodes);
			if (if_block) if_block.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(meta0, "name", "twitter:title");
			attr_dev(meta0, "content", "Svelte examples");
			add_location(meta0, file$1, 97, 1, 2414);
			attr_dev(meta1, "name", "twitter:description");
			attr_dev(meta1, "content", "Cybernetically enhanced web apps");
			add_location(meta1, file$1, 98, 1, 2469);
			attr_dev(meta2, "name", "Description");
			attr_dev(meta2, "content", "Interactive example Svelte apps");
			add_location(meta2, file$1, 99, 1, 2547);
			attr_dev(h1, "class", "visually-hidden");
			add_location(h1, file$1, 102, 0, 2631);
			attr_dev(div0, "class", "repl-container svelte-1cnnfpa");
			toggle_class(div0, "loading", /*isLoading*/ ctx[6]);
			add_location(div0, file$1, 106, 2, 2847);
			attr_dev(div1, "class", div1_class_value = "viewport offset-" + /*offset*/ ctx[5] + " svelte-1cnnfpa");
			add_location(div1, file$1, 104, 1, 2732);
			attr_dev(div2, "class", "examples-container svelte-1cnnfpa");
			add_render_callback(() => /*div2_elementresize_handler*/ ctx[13].call(div2));
			add_location(div2, file$1, 103, 0, 2673);
		},
		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t0, anchor);
			insert_dev(target, h1, anchor);
			append_dev(h1, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			mount_component(tableofcontents, div1, null);
			append_dev(div1, t3);
			append_dev(div1, div0);
			mount_component(repl_1, div0, null);
			append_dev(div2, t4);
			if (if_block) if_block.m(div2, null);
			div2_resize_listener = add_resize_listener(div2, /*div2_elementresize_handler*/ ctx[13].bind(div2));
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*title*/ 128) && title_value !== (title_value = "" + (/*title*/ ctx[7] + " " + (/*title*/ ctx[7] ? "•" : "") + " Svelte Examples"))) {
				document.title = title_value;
			}

			const tableofcontents_changes = {};
			if (dirty & /*sections*/ 1) tableofcontents_changes.sections = /*sections*/ ctx[0];
			if (dirty & /*active_slug*/ 2) tableofcontents_changes.active_section = /*active_slug*/ ctx[1];
			if (dirty & /*isLoading*/ 64) tableofcontents_changes.isLoading = /*isLoading*/ ctx[6];
			tableofcontents.$set(tableofcontents_changes);
			const repl_1_changes = {};
			if (dirty & /*replOrientation*/ 256) repl_1_changes.orientation = /*replOrientation*/ ctx[8];
			if (dirty & /*mobile*/ 16) repl_1_changes.fixed = /*mobile*/ ctx[4];
			repl_1.$set(repl_1_changes);

			if (dirty & /*isLoading*/ 64) {
				toggle_class(div0, "loading", /*isLoading*/ ctx[6]);
			}

			if (!current || dirty & /*offset*/ 32 && div1_class_value !== (div1_class_value = "viewport offset-" + /*offset*/ ctx[5] + " svelte-1cnnfpa")) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (/*mobile*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*mobile*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div2, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tableofcontents.$$.fragment, local);
			transition_in(repl_1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(tableofcontents.$$.fragment, local);
			transition_out(repl_1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div2);
			destroy_component(tableofcontents);
			/*repl_1_binding*/ ctx[11](null);
			destroy_component(repl_1);
			if (if_block) if_block.d();
			div2_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload() {
	const sections = await this.fetch(`examples.json`).then(r => r.json());

	const title_by_slug = sections.reduce(
		(acc, { examples }) => {
			examples.forEach(({ slug, title }) => {
				acc[slug] = title;
			});

			return acc;
		},
		{}
	);

	return { sections, title_by_slug };
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Examples", slots, []);
	let { sections } = $$props;
	let { title_by_slug } = $$props;
	let active_slug;
	let width;
	let offset = 1;
	let repl;
	let isLoading = false;
	const cache = {};

	function showExampleCodeOnChange() {
		$$invalidate(5, offset = 1);
	}

	onMount(() => {
		const onhashchange = () => {
			$$invalidate(1, active_slug = getFragment());
		};

		window.addEventListener("hashchange", onhashchange, false);
		const fragment = getFragment();

		if (fragment) {
			$$invalidate(1, active_slug = fragment);
		} else {
			$$invalidate(1, active_slug = first_slug);
			goto(`examples#${active_slug}`);
		}

		return () => {
			window.removeEventListener("hashchange", onhashchange, false);
		};
	});

	const writable_props = ["sections", "title_by_slug"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Examples> was created with unknown prop '${key}'`);
	});

	function repl_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			repl = $$value;
			$$invalidate(3, repl);
		});
	}

	function screentoggle_offset_binding(value) {
		offset = value;
		$$invalidate(5, offset);
	}

	function div2_elementresize_handler() {
		width = this.clientWidth;
		$$invalidate(2, width);
	}

	$$self.$$set = $$props => {
		if ("sections" in $$props) $$invalidate(0, sections = $$props.sections);
		if ("title_by_slug" in $$props) $$invalidate(9, title_by_slug = $$props.title_by_slug);
	};

	$$self.$capture_state = () => ({
		preload,
		onMount,
		goto,
		Repl,
		ScreenToggle,
		mapbox_setup,
		rollupUrl,
		svelteUrl,
		process_example,
		getFragment,
		TableOfContents,
		sections,
		title_by_slug,
		active_slug,
		width,
		offset,
		repl,
		isLoading,
		cache,
		showExampleCodeOnChange,
		title,
		first_slug,
		mobile,
		replOrientation
	});

	$$self.$inject_state = $$props => {
		if ("sections" in $$props) $$invalidate(0, sections = $$props.sections);
		if ("title_by_slug" in $$props) $$invalidate(9, title_by_slug = $$props.title_by_slug);
		if ("active_slug" in $$props) $$invalidate(1, active_slug = $$props.active_slug);
		if ("width" in $$props) $$invalidate(2, width = $$props.width);
		if ("offset" in $$props) $$invalidate(5, offset = $$props.offset);
		if ("repl" in $$props) $$invalidate(3, repl = $$props.repl);
		if ("isLoading" in $$props) $$invalidate(6, isLoading = $$props.isLoading);
		if ("title" in $$props) $$invalidate(7, title = $$props.title);
		if ("first_slug" in $$props) first_slug = $$props.first_slug;
		if ("mobile" in $$props) $$invalidate(4, mobile = $$props.mobile);
		if ("replOrientation" in $$props) $$invalidate(8, replOrientation = $$props.replOrientation);
	};

	let title;
	let first_slug;
	let mobile;
	let replOrientation;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*title_by_slug, active_slug*/ 514) {
			 $$invalidate(7, title = title_by_slug[active_slug] || "");
		}

		if ($$self.$$.dirty & /*sections*/ 1) {
			 first_slug = sections[0].examples[0].slug;
		}

		if ($$self.$$.dirty & /*width*/ 4) {
			 $$invalidate(4, mobile = width < 768); // note: same as per media query below
		}

		if ($$self.$$.dirty & /*mobile, width*/ 20) {
			 $$invalidate(8, replOrientation = mobile || width > 1080 ? "columns" : "rows");
		}

		if ($$self.$$.dirty & /*repl, active_slug, cache*/ 1034) {
			 if (repl && active_slug) {
				if (active_slug in cache) {
					repl.set({ components: cache[active_slug] });
					showExampleCodeOnChange();
				} else {
					$$invalidate(6, isLoading = true);

					fetch(`examples/${active_slug}.json`).then(async response => {
						if (response.ok) {
							const { files } = await response.json();
							return process_example(files);
						}
					}).then(components => {
						$$invalidate(10, cache[active_slug] = components, cache);
						repl.set({ components });
						showExampleCodeOnChange();
						$$invalidate(6, isLoading = false);
					}).catch(() => {
						$$invalidate(6, isLoading = false);
					});
				}
			}
		}
	};

	return [
		sections,
		active_slug,
		width,
		repl,
		mobile,
		offset,
		isLoading,
		title,
		replOrientation,
		title_by_slug,
		cache,
		repl_1_binding,
		screentoggle_offset_binding,
		div2_elementresize_handler
	];
}

class Examples extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { sections: 0, title_by_slug: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Examples",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*sections*/ ctx[0] === undefined && !("sections" in props)) {
			console.warn("<Examples> was created without expected prop 'sections'");
		}

		if (/*title_by_slug*/ ctx[9] === undefined && !("title_by_slug" in props)) {
			console.warn("<Examples> was created without expected prop 'title_by_slug'");
		}
	}

	get sections() {
		throw new Error("<Examples>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<Examples>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title_by_slug() {
		throw new Error("<Examples>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title_by_slug(value) {
		throw new Error("<Examples>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Examples;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguMTAwMTMzMTMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc2l0ZS1raXQvdXRpbHMvbmF2aWdhdGlvbi5qcyIsIi4uLy4uLy4uL3NyYy91dGlscy9leGFtcGxlcy5qcyIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZXhhbXBsZXMvX1RhYmxlT2ZDb250ZW50cy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2V4YW1wbGVzL2luZGV4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZ2V0RnJhZ21lbnQgPSAoKSA9PiB3aW5kb3cubG9jYXRpb24uaGFzaC5zbGljZSgxKTtcbiIsImV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzX2V4YW1wbGUoZmlsZXMpIHtcblx0cmV0dXJuIGZpbGVzXG5cdFx0Lm1hcChmaWxlID0+IHtcblx0XHRcdGNvbnN0IFtuYW1lLCB0eXBlXSA9IGZpbGUubmFtZS5zcGxpdCgnLicpO1xuXHRcdFx0cmV0dXJuIHsgbmFtZSwgdHlwZSwgc291cmNlOiBmaWxlLnNvdXJjZSB9O1xuXHRcdH0pXG5cdFx0LnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdGlmIChhLm5hbWUgPT09ICdBcHAnICYmIGEudHlwZSA9PT0gJ3N2ZWx0ZScpIHJldHVybiAtMTtcblx0XHRcdGlmIChiLm5hbWUgPT09ICdBcHAnICYmIGIudHlwZSA9PT0gJ3N2ZWx0ZScpIHJldHVybiAxO1xuXG5cdFx0XHRpZiAoYS50eXBlID09PSBiLnR5cGUpIHJldHVybiBhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDE7XG5cblx0XHRcdGlmIChhLnR5cGUgPT09ICdzdmVsdGUnKSByZXR1cm4gLTE7XG5cdFx0XHRpZiAoYi50eXBlID09PSAnc3ZlbHRlJykgcmV0dXJuIDE7XG5cdFx0fSk7XG59IiwiPHNjcmlwdD5cblx0ZXhwb3J0IGxldCBzZWN0aW9ucyA9IFtdO1xuXHRleHBvcnQgbGV0IGFjdGl2ZV9zZWN0aW9uID0gbnVsbDtcblx0ZXhwb3J0IGxldCBpc0xvYWRpbmcgPSBmYWxzZTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cdC5leGFtcGxlcy10b2Mge1xuXHRcdG92ZXJmbG93LXk6IGF1dG87XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJvcmRlci1yaWdodDogMXB4IHNvbGlkIHZhcigtLXNlY29uZCk7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0XHRjb2xvcjogd2hpdGU7XG5cdFx0cGFkZGluZzogM3JlbSAzcmVtIDAgM3JlbTtcblx0fVxuXG5cdC5leGFtcGxlcy10b2MgbGkge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdGxpbmUtaGVpZ2h0OiAxLjI7XG5cdFx0bWFyZ2luOiAwIDAgNC44cmVtIDA7XG5cdH1cblxuXHQuc2VjdGlvbi10aXRsZSB7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZzogMCAwIDAuOHJlbSAwO1xuXHRcdGZvbnQ6IDQwMCB2YXIoLS1oNikgdmFyKC0tZm9udCk7XG5cdFx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcblx0XHRsZXR0ZXItc3BhY2luZzogMC4xMmVtO1xuXHRcdGZvbnQtd2VpZ2h0OiA3MDA7XG5cdH1cblxuXHRkaXYge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IHJvdztcblx0XHRwYWRkaW5nOiAwLjJyZW0gM3JlbTtcblx0XHRtYXJnaW46IDAgLTNyZW07XG5cdH1cblxuXHRkaXYuYWN0aXZlIHtcblx0XHRiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMTUpIGNhbGMoMTAwJSAtIDNyZW0pIDQ3JSBuby1yZXBlYXRcblx0XHRcdHVybCgvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnKTtcblx0XHRiYWNrZ3JvdW5kLXNpemU6IDFlbSAxZW07XG5cdFx0Y29sb3I6IHdoaXRlO1xuXHR9XG5cblx0ZGl2LmFjdGl2ZS5sb2FkaW5nIHtcblx0XHRiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMSkgY2FsYygxMDAlIC0gM3JlbSkgNDclIG5vLXJlcGVhdFxuXHRcdFx0dXJsKC9pY29ucy9sb2FkaW5nLnN2Zyk7XG5cdFx0YmFja2dyb3VuZC1zaXplOiAxZW0gMWVtO1xuXHRcdGNvbG9yOiB3aGl0ZTtcblx0fVxuXG5cdGEge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleDogMSAxIGF1dG87XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdGNvbG9yOiB2YXIoLS1zaWRlYmFyLXRleHQpO1xuXHRcdGJvcmRlci1ib3R0b206IG5vbmU7XG5cdFx0Zm9udC1zaXplOiAxLjZyZW07XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0O1xuXHRcdHBhZGRpbmc6IDA7XG5cdH1cblxuXHRhOmhvdmVyIHtcblx0XHRjb2xvcjogd2hpdGU7XG5cdH1cblxuXHQucmVwbC1saW5rIHtcblx0XHRmbGV4OiAwIDEgYXV0bztcblx0XHRmb250LXNpemU6IDEuMnJlbTtcblx0XHRmb250LXdlaWdodDogNzAwO1xuXHRcdG1hcmdpbi1yaWdodDogMi41cmVtO1xuXHR9XG5cblx0LnRodW1ibmFpbCB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG5cdFx0b2JqZWN0LWZpdDogY29udGFpbjtcblx0XHR3aWR0aDogNXJlbTtcblx0XHRoZWlnaHQ6IDVyZW07XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdGJveC1zaGFkb3c6IDFweCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xMyk7XG5cdFx0bWFyZ2luOiAwLjJlbSAwLjVlbSAwLjJlbSAwO1xuXHR9XG48L3N0eWxlPlxuXG48dWwgY2xhc3M9XCJleGFtcGxlcy10b2NcIj5cblx0eyNlYWNoIHNlY3Rpb25zIGFzIHNlY3Rpb259XG5cdFx0PGxpPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJzZWN0aW9uLXRpdGxlXCI+e3NlY3Rpb24udGl0bGV9PC9zcGFuPlxuXG5cdFx0XHR7I2VhY2ggc2VjdGlvbi5leGFtcGxlcyBhcyBleGFtcGxlfVxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0Y2xhc3M9XCJyb3dcIlxuXHRcdFx0XHRcdGNsYXNzOmFjdGl2ZT17ZXhhbXBsZS5zbHVnID09PSBhY3RpdmVfc2VjdGlvbn1cblx0XHRcdFx0XHRjbGFzczpsb2FkaW5nPXtpc0xvYWRpbmd9PlxuXHRcdFx0XHRcdDxhXG5cdFx0XHRcdFx0XHRocmVmPVwiZXhhbXBsZXMje2V4YW1wbGUuc2x1Z31cIlxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJyb3dcIlxuXHRcdFx0XHRcdFx0Y2xhc3M6YWN0aXZlPXtleGFtcGxlLnNsdWcgPT09IGFjdGl2ZV9zZWN0aW9ufVxuXHRcdFx0XHRcdFx0Y2xhc3M6bG9hZGluZz17aXNMb2FkaW5nfT5cblx0XHRcdFx0XHRcdDxpbWdcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJ0aHVtYm5haWxcIlxuXHRcdFx0XHRcdFx0XHRhbHQ9XCJ7ZXhhbXBsZS50aXRsZX0gdGh1bWJuYWlsXCJcblx0XHRcdFx0XHRcdFx0c3JjPVwiZXhhbXBsZXMvdGh1bWJuYWlscy97ZXhhbXBsZS5zbHVnfS5qcGdcIiAvPlxuXG5cdFx0XHRcdFx0XHQ8c3Bhbj57ZXhhbXBsZS50aXRsZX08L3NwYW4+XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdHsjaWYgZXhhbXBsZS5zbHVnID09PSBhY3RpdmVfc2VjdGlvbn1cblx0XHRcdFx0XHRcdDxhIGhyZWY9XCJyZXBsL3tleGFtcGxlLnNsdWd9XCIgY2xhc3M9XCJyZXBsLWxpbmtcIj5SRVBMPC9hPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9lYWNofVxuXHRcdDwvbGk+XG5cdHsvZWFjaH1cbjwvdWw+XG4iLCI8IS0tIEZJWE1FIHNvbWV0aW1lcyBpdCBhZGRzIGEgdHJhaWxpbmcgc2xhc2ggd2hlbiBsYW5kaW5nIC0tPlxuPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG5cdGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVsb2FkKCkge1xuXHRcdGNvbnN0IHNlY3Rpb25zID0gYXdhaXQgdGhpcy5mZXRjaChgZXhhbXBsZXMuanNvbmApLnRoZW4ociA9PiByLmpzb24oKSk7XG5cdFx0Y29uc3QgdGl0bGVfYnlfc2x1ZyA9IHNlY3Rpb25zLnJlZHVjZSgoYWNjLCB7ZXhhbXBsZXN9KSA9PiB7XG5cdFx0XHRleGFtcGxlcy5mb3JFYWNoKCh7c2x1ZywgdGl0bGV9KSA9PiB7XG5cdFx0XHRcdGFjY1tzbHVnXSA9IHRpdGxlO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSwge30pO1xuXG5cdFx0cmV0dXJuIHtzZWN0aW9ucywgdGl0bGVfYnlfc2x1Z307XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuXHRpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHsgZ290byB9IGZyb20gJ0BzYXBwZXIvYXBwJztcblx0aW1wb3J0IFJlcGwgZnJvbSAnQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsJztcblxuXHRpbXBvcnQgU2NyZWVuVG9nZ2xlIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvU2NyZWVuVG9nZ2xlLnN2ZWx0ZSc7XG5cdGltcG9ydCB7XG5cdFx0bWFwYm94X3NldHVwLCAvLyBzZWUgc2l0ZS9jb250ZW50L2V4YW1wbGVzLzE1LWNvbnRleHQvMDAtY29udGV4dC1hcGlcblx0XHRyb2xsdXBVcmwsXG5cdFx0c3ZlbHRlVXJsXG5cdH0gZnJvbSAnLi4vLi4vY29uZmlnJztcblx0aW1wb3J0IHsgcHJvY2Vzc19leGFtcGxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhhbXBsZXMnO1xuXHRpbXBvcnQgeyBnZXRGcmFnbWVudCB9IGZyb20gJ0BzdmVsdGVqcy9zaXRlLWtpdC91dGlscy9uYXZpZ2F0aW9uJztcblx0aW1wb3J0IFRhYmxlT2ZDb250ZW50cyBmcm9tICcuL19UYWJsZU9mQ29udGVudHMuc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IHNlY3Rpb25zO1xuXHRleHBvcnQgbGV0IHRpdGxlX2J5X3NsdWc7XG5cblx0bGV0IGFjdGl2ZV9zbHVnO1xuXHRsZXQgd2lkdGg7XG5cdGxldCBvZmZzZXQgPSAxO1xuXHRsZXQgcmVwbDtcblx0bGV0IGlzTG9hZGluZyA9IGZhbHNlO1xuXHRjb25zdCBjYWNoZSA9IHt9O1xuXG5cdGZ1bmN0aW9uIHNob3dFeGFtcGxlQ29kZU9uQ2hhbmdlKCkge1xuXHRcdG9mZnNldCA9IDE7XG5cdH1cblxuXHQkOiB0aXRsZSA9IHRpdGxlX2J5X3NsdWdbYWN0aXZlX3NsdWddIHx8ICcnO1xuXHQkOiBmaXJzdF9zbHVnID0gc2VjdGlvbnNbMF0uZXhhbXBsZXNbMF0uc2x1Zztcblx0JDogbW9iaWxlID0gd2lkdGggPCA3Njg7IC8vIG5vdGU6IHNhbWUgYXMgcGVyIG1lZGlhIHF1ZXJ5IGJlbG93XG5cdCQ6IHJlcGxPcmllbnRhdGlvbiA9IChtb2JpbGUgfHwgd2lkdGggPiAxMDgwKSA/ICdjb2x1bW5zJyA6ICdyb3dzJztcblx0JDogaWYgKHJlcGwgJiYgYWN0aXZlX3NsdWcpIHtcblx0XHRpZiAoYWN0aXZlX3NsdWcgaW4gY2FjaGUpIHtcblx0XHRcdHJlcGwuc2V0KHsgY29tcG9uZW50czogY2FjaGVbYWN0aXZlX3NsdWddIH0pO1xuXHRcdFx0c2hvd0V4YW1wbGVDb2RlT25DaGFuZ2UoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXNMb2FkaW5nID0gdHJ1ZTtcblx0XHRcdGZldGNoKGBleGFtcGxlcy8ke2FjdGl2ZV9zbHVnfS5qc29uYClcblx0XHRcdFx0LnRoZW4oYXN5bmMgcmVzcG9uc2UgPT4ge1xuXHRcdFx0XHRcdGlmIChyZXNwb25zZS5vaykge1xuXHRcdFx0XHRcdFx0Y29uc3Qge2ZpbGVzfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzX2V4YW1wbGUoZmlsZXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oY29tcG9uZW50cyA9PiB7XG5cdFx0XHRcdFx0Y2FjaGVbYWN0aXZlX3NsdWddID0gY29tcG9uZW50cztcblx0XHRcdFx0XHRyZXBsLnNldCh7Y29tcG9uZW50c30pO1xuXHRcdFx0XHRcdHNob3dFeGFtcGxlQ29kZU9uQ2hhbmdlKCk7XG5cdFx0XHRcdFx0aXNMb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jYXRjaCgoKSA9PiB7XG5cdFx0XHRcdFx0aXNMb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdG9uTW91bnQoKCkgPT4ge1xuXHRcdGNvbnN0IG9uaGFzaGNoYW5nZSA9ICgpID0+IHtcblx0XHRcdGFjdGl2ZV9zbHVnID0gZ2V0RnJhZ21lbnQoKTtcblx0XHR9O1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgb25oYXNoY2hhbmdlLCBmYWxzZSk7XG5cblx0XHRjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KCk7XG5cdFx0aWYgKGZyYWdtZW50KSB7XG5cdFx0XHRhY3RpdmVfc2x1ZyA9IGZyYWdtZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhY3RpdmVfc2x1ZyA9IGZpcnN0X3NsdWc7XG5cdFx0XHRnb3RvKGBleGFtcGxlcyMke2FjdGl2ZV9zbHVnfWApO1xuXHRcdH1cblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIG9uaGFzaGNoYW5nZSwgZmFsc2UpO1xuXHRcdH07XG5cdH0pO1xuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6aGVhZD5cblx0PHRpdGxlPnt0aXRsZX0ge3RpdGxlID8gJ+KAoicgOiAnJ30gU3ZlbHRlIEV4YW1wbGVzPC90aXRsZT5cblxuXHQ8bWV0YSBuYW1lPVwidHdpdHRlcjp0aXRsZVwiIGNvbnRlbnQ9XCJTdmVsdGUgZXhhbXBsZXNcIj5cblx0PG1ldGEgbmFtZT1cInR3aXR0ZXI6ZGVzY3JpcHRpb25cIiBjb250ZW50PVwiQ3liZXJuZXRpY2FsbHkgZW5oYW5jZWQgd2ViIGFwcHNcIj5cblx0PG1ldGEgbmFtZT1cIkRlc2NyaXB0aW9uXCIgY29udGVudD1cIkludGVyYWN0aXZlIGV4YW1wbGUgU3ZlbHRlIGFwcHNcIj5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxoMSBjbGFzcz1cInZpc3VhbGx5LWhpZGRlblwiPkV4YW1wbGVzPC9oMT5cbjxkaXYgY2xhc3M9J2V4YW1wbGVzLWNvbnRhaW5lcicgYmluZDpjbGllbnRXaWR0aD17d2lkdGh9PlxuXHQ8ZGl2IGNsYXNzPVwidmlld3BvcnQgb2Zmc2V0LXtvZmZzZXR9XCI+XG5cdFx0PFRhYmxlT2ZDb250ZW50cyB7c2VjdGlvbnN9IGFjdGl2ZV9zZWN0aW9uPXthY3RpdmVfc2x1Z30ge2lzTG9hZGluZ30gLz5cblx0XHQ8ZGl2IGNsYXNzPVwicmVwbC1jb250YWluZXJcIiBjbGFzczpsb2FkaW5nPXtpc0xvYWRpbmd9PlxuXHRcdFx0PFJlcGxcblx0XHRcdFx0YmluZDp0aGlzPXtyZXBsfVxuXHRcdFx0XHR3b3JrZXJzVXJsPVwid29ya2Vyc1wiXG5cdFx0XHRcdHtzdmVsdGVVcmx9XG5cdFx0XHRcdHtyb2xsdXBVcmx9XG5cdFx0XHRcdG9yaWVudGF0aW9uPXtyZXBsT3JpZW50YXRpb259XG5cdFx0XHRcdGZpeGVkPXttb2JpbGV9XG5cdFx0XHRcdHJlbGF4ZWRcblx0XHRcdFx0aW5qZWN0ZWRKUz17bWFwYm94X3NldHVwfVxuXHRcdFx0Lz5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG5cdHsjaWYgbW9iaWxlfVxuXHQ8U2NyZWVuVG9nZ2xlIGJpbmQ6b2Zmc2V0IGxhYmVscz17WydpbmRleCcsICdpbnB1dCcsICdvdXRwdXQnXX0vPlxuXHR7L2lmfVxuPC9kaXY+XG5cbjxzdHlsZT5cblx0LmV4YW1wbGVzLWNvbnRhaW5lciB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdGhlaWdodDogY2FsYygxMDB2aCAtIHZhcigtLW5hdi1oKSk7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRwYWRkaW5nOiAwIDAgNDJweCAwO1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdH1cblxuXHQudmlld3BvcnQge1xuXHRcdGRpc3BsYXk6IGdyaWQ7XG5cdFx0d2lkdGg6IDMwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogMzMuMzMzJSA2Ni42NjYlO1xuXHRcdHRyYW5zaXRpb246IHRyYW5zZm9ybSAuM3M7XG5cdFx0Z3JpZC1hdXRvLXJvd3M6IDEwMCU7XG5cdH1cblxuXHQucmVwbC1jb250YWluZXIubG9hZGluZyB7XG5cdFx0b3BhY2l0eTogMC42O1xuXHR9XG5cblxuXG5cdC5yZXBsLWNvbnRhaW5lciA6Z2xvYmFsKC50YWItY29udGVudCksXG5cdC5yZXBsLWNvbnRhaW5lciA6Z2xvYmFsKC50YWItY29udGVudC52aXNpYmxlKSB7XG5cdFx0cG9pbnRlci1ldmVudHM6IGFsbDtcblx0XHRvcGFjaXR5OiAxO1xuXHR9XG5cdC5yZXBsLWNvbnRhaW5lciA6Z2xvYmFsKC50YWItY29udGVudCkge1xuXHRcdHZpc2liaWxpdHk6IGhpZGRlbjtcblx0fVxuXHQucmVwbC1jb250YWluZXIgOmdsb2JhbCgudGFiLWNvbnRlbnQudmlzaWJsZSkge1xuXHRcdHZpc2liaWxpdHk6IHZpc2libGU7XG5cdH1cblxuXHQub2Zmc2V0LTEgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMzMuMzMzJSwgMCk7IH1cblx0Lm9mZnNldC0yIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTY2LjY2NiUsIDApOyB9XG5cblx0QG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG5cdFx0LmV4YW1wbGVzLWNvbnRhaW5lciB7IHBhZGRpbmc6IDAgfVxuXG5cdFx0LnZpZXdwb3J0IHtcblx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0ZGlzcGxheTogZ3JpZDtcblx0XHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogdmFyKC0tc2lkZWJhci1taWQtdykgYXV0bztcblx0XHRcdGdyaWQtYXV0by1yb3dzOiAxMDAlO1xuXHRcdFx0dHJhbnNpdGlvbjogbm9uZTtcblx0XHR9XG5cblx0XHQub2Zmc2V0LTEsIC5vZmZzZXQtMiB7IHRyYW5zZm9ybTogbm9uZTsgfVxuXHR9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFPLE1BQU0sV0FBVyxHQUFHLE1BQU0sTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs7QUNBdkQsU0FBUyxlQUFlLENBQUMsS0FBSyxFQUFFO0FBQ3ZDLENBQUMsT0FBTyxLQUFLO0FBQ2IsR0FBRyxHQUFHLENBQUMsSUFBSSxJQUFJO0FBQ2YsR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzdDLEdBQUcsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUM5QyxHQUFHLENBQUM7QUFDSixHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUs7QUFDbEIsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDMUQsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3pEO0FBQ0EsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDMUQ7QUFDQSxHQUFHLElBQUksQ0FBQyxDQUFD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
